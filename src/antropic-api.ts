#!/usr/bin/env node
import axios from 'axios';
import { fetchPRDiff, formatPRSummary, PRResponse } from './diff_fetcher.js';
import { basicPrompt } from './prompSample.js';
import dotenv from 'dotenv';
dotenv.config();

// Define a type for the summary data payload for clarity
interface SummaryData {
  title: string; // Combined title field: '#<PR number>: <PR Title>'
  url: string;   // PR URL
  authorName: string; // GitHub username of the PR author
  authorIconUrl: string; // URL for the author's avatar
  summary: string; // The summary text generated by AI
  timestamp: string; // ISO string timestamp
}

// Main function to make request to Claude's API
async function askClaudeForSummary(summary: string): Promise<string> {
  let question = basicPrompt;
  question += `\n\nUse this PR content: \n\n${summary}`;
  // console.log(question);
  //return question;
  try {
    const response = await axios({
      method: 'post',
      url: 'https://api.anthropic.com/v1/messages',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': process.env.ANTHROPIC_API_KEY || 'YOUR_API_KEY_HERE',
        'anthropic-version': '2023-06-01'
      },
      data: {
        model: 'claude-3-7-sonnet-20250219', // Latest model
        max_tokens: 1000,
        messages: [
          {
            role: 'user',
            content: question
          }
        ]
      }
    });
    return response.data.content[0].text;
  } catch (error: any) {
    console.error('Error querying Claude API:', error.response?.data || error.message);
    throw error;
  }
}

// Function to get the question from command line arguments
function getPromptFromArgs(): string {
  // Take all arguments after "node script.js"
  const args = process.argv.slice(2);

  // If no arguments provided, show help and exit
  if (args.length === 0) {
    console.log('Usage: node dist/antropic-api.js "Your question for Claude here"');
    process.exit(1);
  }

  // Join all arguments into a single string (in case the question has spaces)
  return args.join(' ');
}

export async function summarizePr(prResponse: PRResponse): Promise<string> {
  try {
    const prSummary = await fetchPRDiff(prResponse);
    const formattedSummary = formatPRSummary(prSummary);
    const res = await askClaudeForSummary(formattedSummary);
    return res;
  } catch (error) {
    console.error('Failed to process PR:', error);
    return 'Failed to summarize PR';
  }
}

// New function to send summary data to Slack using Block Kit
export async function sendSummaryToSlack(summaryData: SummaryData): Promise<void> {
  const slackWebhookUrl = process.env.SLACK_WEBHOOK_URL;
  if (!slackWebhookUrl) {
    console.error('Slack webhook URL not found in environment variables (SLACK_WEBHOOK_URL).');
    return;
  }

  try {
    // Extract the core summary text, removing potential numbering/prefixes
    let coreSummary = summaryData.summary;
    const summaryPrefix = "SUMMARY:";
    const summaryIndex = coreSummary.toUpperCase().indexOf(summaryPrefix);
    if (summaryIndex !== -1) {
      coreSummary = coreSummary.substring(summaryIndex + summaryPrefix.length).trim();
    }
    // Optional: Remove potential leading numbering like "2. " if it exists after trimming
    if (/^\d+\.\s/.test(coreSummary)) {
      coreSummary = coreSummary.replace(/^\d+\.\s/, '');
    }

    // Construct the Block Kit message payload
    const blocks = [
      // Header Section: PR Title and Link
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `üöÄ New PR Summary!`,
          emoji: true
        }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*<${summaryData.url}|${summaryData.title}>*`
        }
      },
      // Divider
      {
        type: 'divider'
      },
      // Author Information Section
      {
        type: 'context',
        elements: [
          {
            type: 'image',
            image_url: summaryData.authorIconUrl,
            alt_text: `${summaryData.authorName}'s avatar`
          },
          {
            type: 'mrkdwn',
            text: `*Author:* ${summaryData.authorName}`
          }
        ]
      },
      // Summary Section
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*üìù Summary:*
${coreSummary}`
        }
      },
      // Divider
      {
        type: 'divider'
      },
      // Timestamp (optional, nice context)
      {
        type: 'context',
        elements: [
          {
            type: 'mrkdwn',
            text: `Generated: <!date^${Math.floor(new Date(summaryData.timestamp).getTime() / 1000)}^{date_short_pretty} at {time}|${new Date(summaryData.timestamp).toLocaleString()}>`
          }
        ]
      }
    ];

    await axios.post(slackWebhookUrl, {
      blocks: blocks,
      // Fallback text for notifications that don't support Block Kit
      text: `New PR Summary: ${summaryData.title} by ${summaryData.authorName} - ${summaryData.summary}`
    });
    console.log('Summary sent to Slack using Block Kit');
  } catch (slackError: any) {
    console.error('Failed to send summary to Slack:', slackError.response?.data || slackError.message);
  }
}
